---
title: "基础语法速通③"
date: 2024-02-15T13:45:07+08:00 
lastmod: 2024-02-15T13:45:07+08:00
author: ["Sharker"] 
categories: 
- 语法
tags: 
- Go
description: "Go基础语法速通, 速通Go语言中关键语法"
weight: 
slug: ""
draft: false 
comments: true 
showToc: true 
TocOpen: true 
hidemeta: false 
showbreadcrumbs: true 
---
继续前面的整理，这将是最后一部分的整理内容，包括了goroutine channel的使用以及Go反射的使用。

## Go goroutine channel
### 进程 线程 并行 并发
#### 进程 线程
进程就是程序在操作系统中的一次执行过程，是系统进行资源分配和调度的基本单位，进程是一个动态概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有自己的地址空间，一个进程中至少有5个基本状态，初始态、执行态、等待状态、就绪状态、终止状态。通俗的讲进程就是一个正在执行的程序。

线程是进程的一个执行实例，是程序执行的最小单元，它是比进程更小的能独立运行的基本单位，一个进程可以创建多个线程，同一个进程中的多个线程可以并发执行，一个程序要运行的话至少有一个进程

![CleanShot 2024-01-21 at 12.15.30@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.15.30@2x.png)

#### 并发 并行
- 并发 多个线程同时竞争一个位置，竞争到的才可以执行，同一个时间段内只有一个线程在执行
- 并行 多个线程可以同时执行，每个时间段内，可以有多个线程同时执行

通俗的讲多线程程序在单核CPU上面运行就是并发，多线程程序在多核CPU上运行就是并行，如果线程数大于CPU数，则多线程程序在多核CPU上面运行既有并行又有并发。

![CleanShot 2024-01-21 at 12.16.18@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.16.18@2x.png)

![CleanShot 2024-01-21 at 12.16.31@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.16.31@2x.png)

区别在于同一时刻是否有多个任务正在被执行

### Go中的协程(goroutine)以及主线程
Go主线程，在主线程上可以起多个协程，Go中多协程可以实现并行或并发。
协程，可以理解为用户级别的线程，这是对于内核透明的，也就是系统并不知道有协程的存在，是完全由用户自己的程序进行调度的，Go的一个特色就是从语言层面原生支持协程，在函数或者方法前面加go关键字就可以创建一个协程，可以说go中的写成就是goroutine。

多协程与多线程，Go中每个Goroutine默认占用内存远比java、c中的线程少的多，OS线程一般都固定了栈内存(2m)，一个Goroutine占用的内存非常小只有2k左右，多协程Goroutine切换调度开销方面远比线程少的多，这也就是go更加适合并发场景的原因。

![CleanShot 2024-01-21 at 12.18.23@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.18.23@2x.png)

![CleanShot 2024-01-21 at 12.21.25@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.21.25@2x.png)

![CleanShot 2024-01-21 at 12.19.00@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.19.00@2x.png)
> 多协程切换调度开销远比线程要少

### Goroutine的使用以及sync.WaitGroup
#### Goroutine的使用
在主线程中，开启一个Goroutine，该协程每隔50毫秒输出“你好go”在主线程中也没个50毫秒输出“你好go”，输出10次后退出程序，要求主线程和Goroutine同时执行

![CleanShot 2024-01-21 at 12.29.28@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.29.28@2x.png)

![CleanShot 2024-01-21 at 12.27.29@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.27.29@2x.png)

> 主线程执行完毕后即使协程没有执行完毕程序也会退出，使用sync.WaitGroup来等待协程执行完毕

#### sync.WaitGroup
实现等待协程执行完毕
`var wg sync.WaitGroup`
![CleanShot 2024-01-21 at 12.32.28@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.32.28@2x.png)

### 设置Go中并行运行的时候占用CPU的数目
Go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来同时执行GO代码，默认值是机器上的CPU核心数，例如在一个8核心的机器上，调度器会把Go代码同时调度到8个OS线程上。

Go语言中可以通过`runtime.GOMAXPROCS()`函数设置当前程序并发时占用的CPU核心数，Go1.5版本之前是单核心执行，1.5版本后默认使用全部的CPU核心数。

```go
func main() {
    // 获取当前计算机上面的cpu个数
    cpuNum := runtime.NumCPU()
    fmt.Println("cpuNum=", cpuNum)

    runtime.GOMAXPROCS(cpuNum - 1)
    fmt.Println("ok")
}
```

### Goroutine 例子
![CleanShot 2024-01-21 at 12.39.17@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2012.39.17@2x.png)

#### 统计1-10000000的数字中的素数
1. 传统方法 通过一个for循环判断各个数是不是素数
![CleanShot 2024-01-21 at 16.29.42@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2016.29.42@2x.png)

2. 使用并发或者并行的方式，将统计素数的任务分配给多个goroutine去完成，这个时候就用到了goroutine
![CleanShot 2024-01-21 at 16.31.29@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2016.31.29@2x.png)
> `start:(n-1)*30000+1` `end: n*30000`

![CleanShot 2024-01-21 at 16.36.31@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2016.36.31@2x.png)

![CleanShot 2024-01-21 at 16.36.14@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-21%20at%2016.36.14@2x.png)

> 开启四个goroutine 进行循环

### 协程之间的通信 -- Channel管道
管道是Go在语言级别上提供的goroutine间的通信方式，可以使用channel在多个goroutine之间传递消息，如果goroutine是Go程序并发的执行体，channel就是他们之间的连接，channel是可以让一个goroutine发送特定值到另一个goroutine的通信机制。

Go并发模型是CSP，提倡通过通信共享内存而不是通过共享内存而实现通信。
Go语言中的管道是一种特殊的类型，管道像一个传送带或者队列，总是遵从先入先出的规则，保证收发数据的顺序。每一个管道都是一个具体类型的导管，也就是声明channel的时候需要为其指定元素类型。

#### channel 类型
channel是一种类型，一种引用类型，声明管道类型的格式如下
```go
var 变量 chan 元素类型

var ch1 chan int // 声明一个传递整型的管道
var ch2 chan bool // 声明一个传递bool类型的管道
var ch3 chan []int // 声明一个切片int切片的管道
```

#### 创建channel
声明的管道后需要使用make函数初始化之后才能使用
`make(chan 元素类型, 容量)`

```go
// 创建一个能存储10个int类型数据的管道
ch1 := make(chan int, 10)
// 创建一个能存储4个 bool类型数据的管道
ch2 := make(chan bool, 4)
// 创建一个能存储3个[]int切片类型数据的管道
ch3 := make(chan []int, 3)
```

#### channel操作
管道有发送、接受和关闭三种操作，发送和接收都是使用<-符号，现在我们先使用以下语句定义一个管道
`ch := make(chan int, 3)`
1. 发送 将数据放在管道内
将一个值发送到管道中
`ch <- 10` 把10发送到ch中

2. 接受 (从管道内取值)
从一个管道中接收值
```go
x := <- ch // 从ch中接收值并赋值给变量x
<- ch // 从ch中接收值，忽略结果
```
> 管道是引用数据类型 使用make初始化

![CleanShot 2024-01-23 at 00.38.18@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2000.38.18@2x.png)

![CleanShot 2024-01-23 at 00.40.43@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2000.40.43@2x.png)

![CleanShot 2024-01-23 at 00.47.40@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2000.47.40@2x.png)

![CleanShot 2024-01-23 at 00.49.08@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2000.49.08@2x.png)
> 放不下数据的时候会阻塞，已经取完了再取的时候会阻塞

### 管道循环
当向管道中发送完数据时，我们可以通过close函数关闭管道，当管道被关闭时，再往管道发送值可能会引发panic，从改管道取值的操作会先取完管道中的值，然后取到的值一直都是对应类型的零值。那么该如何判断管道是否被关闭了呢？

使用for range遍历管道，当管道被关闭的时候就会退出for range，如果没有关闭管道就会报个错误fatal error all Goroutines are asleep - deadlock

通过for range来遍历管道数据，管道没有key
```go
for val := range ch1 {
    fmt.Println(val)
}
```

![CleanShot 2024-01-23 at 12.37.19@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2012.37.19@2x.png)
> 要关闭管道不然的话会死锁 (写入完成后

![CleanShot 2024-01-23 at 12.38.18@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2012.38.18@2x.png)

![CleanShot 2024-01-23 at 12.39.53@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2012.39.53@2x.png)
> 通过for循环循环遍历管道的时候可以不关闭管道，不知道啥时候管道关闭的时候使用for循环来遍历管道 但是要知道数据有多少不然的话就一直读取了零值

### goroutine 结合Channel管道
需求: 定义两个方法一个方法给管道里面写数据，一个给管道里面读取数据，要求同步进行
- 开启一个fn1的协程给管道inChan中写入100条数据
- 开启一个fn2的协程读取inChan中写入的数据
- 注意fn1和fn2同时操作一个管道
- 主线程必须等待操作完成后才可以退出

![CleanShot 2024-01-23 at 13.17.09@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-23%20at%2013.17.09@2x.png)

> 使用goroutine的时候管道没数据不会报错会等待 继续等待读取
> 多个goroutine可以共享channel中的数据

### Goruntine 与 Channel 统计素数例子
- 协程的个数
- 统计和打印并行执行

![CleanShot 2024-01-25 at 00.21.36@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2000.21.36@2x.png)
> 极致的并行

//TODO: 完善写下这个代码
[视频地址](https://www.bilibili.com/video/BV1XY4y1t76G/?p=44&spm_id_from=pageDriver&vd_source=1ce8f381eab5d06dd966abe30310ea9a)

### 单向管道
有时候我们会将管道作为参数在多个任务函数间传递，很多时候我们在不同的任务函数中使用管道会对其进行限制，比如限制管道在函数中只能发送或者只能接收。

```go
// 在默认情况下管道是双向的
var chan1 chan int // 可读可写

// 声明只写的管道
var chan2 chan <- int
chan2 = make(chan int, 3)
chan2 <- 20
// num := <- chan2 // error

// 声明为只读
var chan3 <- chan int
num2 := <- chan3
// chan3 <- 30 // error
```

`ch := make(chan int, 2)`   读写管道
`ch := make(chan<- int, 2)` 只写管道
`ch := make(<-chan int, 2)` 只读管道

### select多路复用
在某些场景下我们需要同时从多个通道接受数据，这个时候可以使用go中给我们提供的select多路复用，通常情况下载通道接受数据时，如果没有数据可以接收将会发生阻塞，比如下面的代码来实现从多个通道接收数据的时候就会发生阻塞。

![CleanShot 2024-01-25 at 22.40.39@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2022.40.39@2x.png)

![CleanShot 2024-01-25 at 22.41.58@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2022.41.58@2x.png)
> 使用select多路复用来获取chan的数据的时候不需要将chan关闭

### goroutine recover 解决协程中出现的panic问题
![CleanShot 2024-01-25 at 22.47.11@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2022.47.11@2x.png)

![CleanShot 2024-01-25 at 22.47.40@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2022.47.40@2x.png)

### Golang并发安全和锁
#### 互斥锁
互斥锁是传统并发编程中对于共享资源进行访问控制的主要手段，他是由标准库sync中的Mutex结构体类型表示，sync.Mutex类型只有两个公开的指针方法，Lock和Unlock。Lock锁定当前共享资源，Unlock进行解锁。

```go
var mutex sync.Mutex
mutex.Lock()
mutex.Unlock()
```

![CleanShot 2024-01-25 at 22.56.51@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2022.56.51@2x.png)
> 顺序输出，不会由于加了go而数据错乱，因为添加了mutex.Lock()

#### 读写互斥锁
互斥锁的本质是当一个goroutine访问的时候，其他的goroutine都不能访问，这样在资源同步，避免竞争的同时也降低了程序的并发性能，程序由原本的并行执行变成了串行执行

其实当对一个不会变化的数据只做读操作的话是不会存在资源竞争的问题，因为数据是不变的，不管怎么读取，多少goroutine同时读取，都是可以的。

所以问题不是出在读上，而是写上，修改的数据要同步，这样其他的goroutine才可以感知的到，所以真正的互斥应该是读取和修改，修改与修改之间的，读和读是没有互斥的必要性的。

所以对于互斥锁提出了一种性能更好的读写锁，读写锁可以让多个读操作并发执行同时读取，但是对于写操作是完全互斥的，也就是说，**当一个goroutine进行写操作的时候，其他的goroutine既不能进行读操作，也不能进行写操作**。

> 读写锁是 读与读操作不互斥，读与写操作互斥，写与写操作互斥


![CleanShot 2024-01-25 at 23.20.43@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2023.20.43@2x.png)

![CleanShot 2024-01-25 at 23.26.24@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2023.26.24@2x.png)

![CleanShot 2024-01-25 at 23.26.03@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-25%20at%2023.26.03@2x.png) 

完整代码
```go
var wg sync.WaitGroup
var mutex sync.RWMutex

func write() {
	mutex.Lock()
	fmt.Println("执行写操作")
	time.Sleep(time.Second * 2)
	mutex.Unlock()
	wg.Done()
}

func read() {
	mutex.RLock()
	fmt.Println("执行读操作")
	time.Sleep(time.Second * 1)
	mutex.RUnlock()
	wg.Done()
}

func main() {
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go read()
	}

	for i := 0; i < 10; i++ {
		wg.Add(1)
		go write()
	}

	wg.Wait()
}
```

## Go 反射


