---
title: "基础语法速通 二"
date: 2024-02-10T23:20:23+08:00 
lastmod: 2024-02-10T23:20:23+08:00
author: ["Sharker"] 
categories: 
- 语法
tags: 
- Go
description: "Go基础语法速通, 速通Go语言中关键语法"
weight: 
slug: ""
draft: false 
comments: true 
showToc: true 
TocOpen: true 
hidemeta: false 
showbreadcrumbs: true 
---
上一篇我们根据大地老师的[B站视频](https://www.bilibili.com/video/BV1XY4y1t76G/?p=3&spm_id_from=pageDriver&vd_source=1ce8f381eab5d06dd966abe30310ea9a)学习了一部分Go语言语法的基础部分，接下来让我继续开始学习，在这篇中将继续总结函数、接口、time包、
指针与结构体等重要的语法基础。

## Go 函数
### 函数定义
函数是组织好的、可重复使用的、用于执行指定任务的代码块。本文介绍了Go语言中函数的相关内容。
Go语言支持的函数类型包括: 函数、匿名函数、闭包
Go语言中定义函数使用func关键字，具体格式如下
```go
func 函数名(参数)(返回值){
    函数体
}
```

#### 函数参数
![CleanShot 2024-01-10 at 00.37.27@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-10%20at%2000.37.27@2x.png)
从上面的定义可以看出参数的定义是使用`形参名1 类型, 形参名2 类型`，如果形参类型一样的话可以简写中间用逗号分隔
![CleanShot 2024-01-10 at 00.40.27@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-10%20at%2000.40.27@2x.png)

如果要定义的函数包含可变的参数则需要将函数的形参定义为可变形参，函数的可变参数是指函数的参数数量不固定，go语言中的可变参数通过在参数名后面(参数类型前面)加上`...`来表示可变参数(区别于针对于数组的拆解)
当可变参数与固定参数同时出现，可变参数放在**最后一个形参**的位置。

```go
// num 表示输入的参数个数， elements为参数元素
func sum(num int, elements ...int) {
	fmt.Printf("%T\n", elements) // 传进来的参数类型为对应类型的切片
	fmt.Println(num)
	sum := 0
	for _, v := range elements {
		sum += v
	}
	fmt.Println(sum)
}
```

#### 返回值
```go
func sum1(nums ...int) (int, int) {
	sum := 0
	count := 0
	for _, v := range nums {
		sum += v
		count += 1
	}
	return sum, count // return 关键字一次可以返回多个值
}

func main() {
	sum, count := sum1(1, 2, 3, 4, 5)
	fmt.Println(sum, count)
}
```
函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过return关键字返回返回的时候直接写return就OK了
![CleanShot 2024-01-10 at 00.54.48@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-10%20at%2000.54.48@2x.png)

![CleanShot 2024-02-11 at 17.28.30@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-02-11%20at%2017.28.30@2x.png)
> 使用命名返回值和未命名返回值结合是不允许的

### 函数变量作用域
和其他语言一样go语言中也包含了全局变量与局部变量，同时也有全局作用域和局部作用域
- 全局变量\作用域 全局变量是定义在函数外部的变量，在程序整个运行周期都是有效的
- 局部变量\作用域 局部变量是函数内部定义的变量，函数内定义的变量无法在该函数外使用

### 函数类型与变量
和其他语言一样在Go语言中函数也是有类型与变量的概念的(函数是一等公民)
我们可以定义函数类型，通过`type`关键在来定义一个函数类型, 具体的格式如下
`type calculation func(int, int) int`
上面语句定义了一个calculation类型，他是一个函数类型，这种函数接受两个int类型的参数并且返回一个int类型的返回值，只要符合两个int参数，一个int返回值的函数都是calculation类型的函数
> 整体来说就是形如`type 函数名 func(int, int) int`
> type关键字不光可以定义函数类型，也可以定义我们自己的数据类型，比如定义一个自己的int类型`type myInt int`

![CleanShot 2024-01-11 at 00.01.14@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2000.01.14@2x.png)

### 方法作为返回值和参数
#### 方法作为参数
```go
type calcType func(int, int) int
func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func calc(x, y int, fun calcType) int {
	return fun(x, y)
}

func main() {
	fmt.Println(calc(1,2, add))
}
```

#### 函数作为返回值
```go
type calcType func(int, int) int
func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}

func calc(x, y int, fun calcType) int {
	return fun(x, y)
}

func operation(op string) calcType {
	switch op {
	case "+":
		return add
	case "-":
		return sub
	case "*":
		return func(i1, i2 int) int { // 匿名函数
			return i1 * i2
		}
	default:
		return nil
	}
}

func main() {
	f := operation("*")
	fmt.Println(f(2,2))
}
```

### 匿名函数
go语言中不支持函数的嵌套，但是可以定义匿名函数，匿名函数就是没有函数名的函数，匿名函数因为没有函数名，所以没法像普通函数那样调用，所以匿名函数必须要保存到某个变量中，或者设置为自执行在匿名函数后直接加()

匿名函数的定义格式如下
```go
func(参数)(返回值) {
    函数体
}
```

自执行函数格式如下
```go
func main() {
    // 匿名函数 匿名自执行函数
    func(形参) {
        函数体
    }(实参)
}
```

```go
type calcType func(int, int) int
func operation(op string) calcType {
	switch op {
	case "+":
		return add
	case "-":
		return sub
	case "*":
		return func(i1, i2 int) int { // 匿名函数
			return i1 * i2
		}
	default:
		return nil
	}
}

func main() {
	f := calc(3, 4, func(i1, i2 int) int {
		return i1 * i2
	})
	fmt.Println(f)

    var fn = func(x, y int) int {
        return x * y
    }
    res := calc(3,4, fn)
    fmt.Println(res)

    // 匿名自执行函数 形参 实参 函数体
    fmt.Println(func (x, y int) int {
		return x * y
	}(3, 4))
}
```

### 函数递归调用
函数调用函数本身为递归，由于函数调用函数没有结束条件，所以要注意设置递归的出口，否则将会一直递归的调用下去。

最经典的例子就是实现阶乘
```go
func fn(n int) int {
    if n > 1 { // 递归调用出口
        return n * fn(n - 1)
    } else {
        return 1
    }
}
```

### 闭包
闭包可以理解为定义在一个函数内部的函数，在本质上闭包是将函数内部和函数外部连接起来的桥梁，或者说是函数和其引用环境的组合体。
- 闭包是指有权访问另一个函数作用域中的变量的函数
- 创建闭包的常见的方式就是在一个函数内部创建另一个函数，通过另一个函数访问这个函数中的局部变量
> 由于闭包里作用域返回的局部变量资源不会被立刻销毁回收，所以可能会占用更多的内存，过渡的使用闭包会导致性能的下降，建议在非常有必要的时候才使用闭包
ps: 这里通过闭包创建的局部变量的回收时机 -- Go的GC处理

```go
func adder() func(int) int {
    var x int
    return func(y int) int {
        x += y
        return x
    }
}
```

这里补充下前面提到的全局变量和局部变量的特点
全局变量
- 常驻内存
- 污染全局

局部变量
- 不常驻内存
- 不污染全局

Go语言中的闭包包含如下特点
- 可以让一个常量常驻内存
- 可以让一个变量不污染全局

![CleanShot 2024-01-11 at 00.52.10@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2000.52.10@2x.png)

![CleanShot 2024-01-11 at 00.57.29@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2000.57.29@2x.png)
![CleanShot 2024-01-11 at 00.57.59@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2000.57.59@2x.png)

> 在返回的闭包中创建的局部变量是否被立即释放要看看闭包中是否对于局部变量有操作(引用)，如果有操作不会立即释放否则会释放 --- 要了解下Go中对于闭包的GC

> 闭包可以解决将变量常驻内存且不污染全局

### defer 语句
Go语言中的defer语句会将其后面跟随的语句进行延迟处理，在defer归属的函数即将返回时，将延迟处理的语句按照defer定义的逆序顺序进行执行，也就是说先被defer的语句最后被执行，最后被defer的语句最先被执行。

![CleanShot 2024-01-11 at 13.07.45@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2013.07.45@2x.png)

![CleanShot 2024-01-11 at 13.07.59@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2013.07.59@2x.png)

![CleanShot 2024-01-11 at 13.07.32@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2013.07.32@2x.png)

命名返回值与匿名返回值在defer的表现有不同，具体可以参照上面的demo，对于这种表现是由于defer执行时机导致的。
![CleanShot 2024-01-11 at 13.08.52@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2013.08.52@2x.png)

下面再看看这个例子
![CleanShot 2024-01-11 at 22.35.16@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2022.35.16@2x.png)

![CleanShot 2024-01-11 at 22.39.19@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2022.39.19@2x.png)

> 由于defer在注册时要确定所有的参数，所以会先执行作为子函数的`calc("A", x, y), calc("B", x, y)`


### panic/recover
Go语言中目前是没有异常机制，但是使用``panic/recover`模式来处理错误，panic可以在任何地方引发，但是recover只有在defer调用的函数中有效。类似于其他函数中的try/throw

![CleanShot 2024-01-11 at 22.59.34@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2022.59.34@2x.png)

fn1
error: 抛出异常
结束

![CleanShot 2024-01-11 at 23.03.02@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2023.03.02@2x.png)

error: runtime error: integer divide by zero
结束
5

### defer panic recover 结合使用
![CleanShot 2024-01-11 at 23.08.36@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-11%20at%2023.08.36@2x.png)

给管理员发送邮件

## Go 结构体
Go中没有类的概念，Go中结构体和其他语言中的类有些相似，和其他面向对象的语言中的类相比，Go中的结构体具有更高的扩展性和灵活性

Go中基础数据类型可以表示一些事物的基本属性，但是当我们想飙到一个事物的全面或者部分属性时，这个时候再用单一的基本数据类型就无法满足要求了，Go提供了一种自定义数据类型，可以封装多个基本数据类型，这种数据类型叫结构体，英文名叫struct也就是我们可以通过struct来定义自己的类型
> 结构体的首字母可以大写也可以小写，大写表示这个结构体是公有的，在其他的包里面也可以使用，小写表示私有的只能在本包中使用

### struct 定义
Go 中通过type关键字定义一个结构体，在讲解结构体之前，首先介绍下通过type关键字自定义类型以及定义类型别名。

#### 自定义类型
在Go语言中有一些基本的数据类型，如string、 int、float、bool等，Go中可以使用type关键字来定义自定义类型
`type myInt int`
> 上面代码表示将myInt定义为int类型，通过type关键字的定义，myInt就是一种新的类型，他具有int的特性

#### 类型别名
TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型，就像一个孩子有大名小名英文名但这些名字都是指他本人
`type TypeAlias = Type`
> 在go语言中有两个类型别名，rune和byte他们的底层定义如下
> `type byte = uint8` // 表示占一个字节的字符 字母
> `type rune = int32` // 表示占4个字节的字符 中文 特殊符号

![CleanShot 2024-01-14 at 00.20.01@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2000.20.01@2x.png)

![CleanShot 2024-01-14 at 00.20.37@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2000.20.37@2x.png)

> 自定义类型打印出来的类型就是自定义的类型，类型别名定义的打印出来的类型就是原本的类型

### 结构体定义与初始化
#### 定义
使用type和struct关键字来定义结构体，具体代码如下
```go
type 类型名 struct {
	字段名 字段类型
	字段名 字段类型
}
```
- 类型名 表示自定义结构体的名称，在同一个包中不可以重复
- 字段名 表示结构体字段名，结构体中的字段名必须唯一
- 字段类型 表示结构体字段的具体类型 任意类型

#### 实例化
只有当结构体实例化后才会真正的分配内存，也就是必须实例化后才能使用结构体的字段

结构体的字段可以是: 基本数据类型、也可以是切片、Map以及结构体，如果结构体的字段类型是指针，slice和map的零值都是nil，即没有分配空间，如果需要使用这样的字段需要先make后才能使用

1. 方式一
结构体本身也是一种类型，可以像声明内置类型一样使用var关键字声明结构体类型
`var 结构体实例 结构体类型`
![CleanShot 2024-01-14 at 15.00.00@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.00.00@2x.png)
2. 方式二
可以通过`new`关键字对结构体进行实例化，得到结构体的地址
```go
func main() {
	var p2 = new(person)
	p2.name = "张三"
	p2.sex = "男"
	p2.age = 20
	fmt.Pirntf("值:%v 类型:%T\n", p2, p2) // 值:{张三 20 男} 类型main.Person
}
```
> 通过new返回的是指针类型的实例

![CleanShot 2024-01-14 at 15.04.49@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.04.49@2x.png)
> 在go中支持对结构体指针直接使用，来访问结构图id成员，在底层 `p2.name = "张三"`会转化为`(*p2).name = "张三"`

3. 方式三
使用&对结构体进行取地址操作相当于对该结构体类型进行一次new实例化操作

![CleanShot 2024-01-14 at 15.06.44@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.06.44@2x.png)
核心在于`p3 := &Person{}` 等同于 new一次
> 和方式二基本一样，可以理解为对于new的简写 (得到的也是对应类型的实例的指针)

4. 方式四
类似于对于map直接赋值，直接对于结构体中的字段进行赋值即可
![CleanShot 2024-01-14 at 15.10.06@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.10.06@2x.png)

![CleanShot 2024-01-14 at 15.10.57@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.10.57@2x.png)
> 得到的是值类型

5. 方式五
![CleanShot 2024-01-14 at 15.11.34@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.11.34@2x.png)
> 得到的是指针类型 其实相当于对于方法4的取地址

6. 方式六
![CleanShot 2024-01-14 at 15.12.15@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.12.15@2x.png)
> 可以部分赋值部分不赋值，不赋值的是类型的默认值

7. 方式七
![CleanShot 2024-01-14 at 15.12.43@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2015.12.43@2x.png)
加不加取地址都可以加了是指针类型，不加是值类型
> 顺序要和定义的对齐

### 结构体方法和接收者
在go语言中，没有类的概念但是可以给行(结构体 自定义类型)定义方法，所谓方法就是定义了接受者的函数，接受者的概念就类似于其他语言中的this或者self。
方法的定义格式如下
```go
func(接收者变量 接收者类型) 方法名(参数列表)(返回参数) {
	函数体
}
```
- 接受者变量 接收者中的参数变量名在命名时，官方建议使用接受者类型名的第一个小写字母，而不是self或者this之类的命名，例如 Person类型的接受者变量应该命名为p，Connector类型的接受者变量应该命名为c等。
- 接收者类型和参数类型相似，可以是指针类型也可以是非指针类型
- 方法名、参数列表、返回参数具体格式于参数定义相同

```go
type Person struct {
	name string
	age  int
	sex  string
}

func (p Person) printInfo() {
	fmt.Printf("姓名: %v 年龄: %v", p.name, p.age)
}

func main() {
	p := &Person{
		name: "Sharker",
		age: 10,
		sex: "男",
	}
	p.printInfo()
}
```
### 任意类型添加方法
在go中，接受者的类型可以是任意类型，不静静是结构体，任意类型都可以拥有方法举个例子在基于int类型使用type关键字可以定义新的自定义类型，然后为新定义自定义添加方法
```go
type myInt int
func (m myInt) sayHello(){
	fmt.Println("Hello 我是一个int")
}

func main() {
	var m1 myInt
	m1.sayHello()
}
```
> 非本地类型不能定义犯法，也就是说我们不能给别的包的类型定义方法
> 通过给新类型增加方法其实就和iOS开发中的扩展有点类似，增加方法不增加成员变量

### 结构体的嵌套与继承
#### 结构体的匿名字段
结构体允许其他成员字段在声明时没有字段名而只有类型，这种没有名字的字段就成为匿名字段
```go
type Person struct {
	string
	int
}

func main() {
	p := Person{
		"小王子",
		18
	}
	fmt.Println(p.string)
}
```
> 匿名字段默认采用类型名作为字段名，结构体要求字段名必须是唯一的因此一个结构体中同种类型的匿名字段只能有一个, 结构体中命名字段和匿名字段不可以混合定义

#### 结构体的嵌套
```go
type User struct {
	Username string
	Password string
	Address Address // 表示User结构体嵌套Address结构体
}
type Address struct {
	Name string
	Phone string
	City string
}
```
还可以使用匿名嵌套的方式
```go
type User struct {
	Username string
	Password string
	Address
}

type Address struct {
	Name string
	Phone string 
	City string
}
```

```go
type UserInfo struct {
	Username string
	Password string
	Address 
}
type Address struct {
	Name string
	Phone string
	City string
}

func main() {
	u := UserInfo {
		Username: "Sharker",
		Password: "xxxx",
		// 嵌套结构体 可以定义匿名字段和命名字段混用
		Address: Address{
			Name: "北京",
			Phone: "13263235040",
			City: "北京",
		},
	}
	fmt.Println(u)
}
```
> 赋值和调用和命名的一样

![CleanShot 2024-01-14 at 17.04.09@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2017.04.09@2x.png)
> 当访问结构体成员时会去查找结构体中查找该字段，如果找不到再去匿名结构体中查找 简单点说就是内部嵌套的结构体字段也可以在外层直接访问到

#### 结构体命名访问冲突
优先访问的是嵌套其他结构体中的字段(外层的字段)，访问被嵌套的需要加上结构体前缀
![CleanShot 2024-01-14 at 17.10.38@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2017.10.38@2x.png)
> 二义性了 需要加上结构提的前缀

### 结构体的继承
结构体的继承是通过结构体的嵌套来实现的

![CleanShot 2024-01-14 at 17.13.18@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2017.13.18@2x.png)

![CleanShot 2024-01-14 at 17.13.36@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2017.13.36@2x.png)

![CleanShot 2024-01-14 at 17.18.45@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2017.18.45@2x.png)

> 因为dog没有Name属性但是在调用Name的时候发现本结构体中没有的话就会去子结构体中寻找从而实现了dog继承了Animal相关的属性与方法
> 结构体中可以嵌套另一个结构体或者结构体指针

### 结构体与json相互转化
当时用Go语言写一些RESTFul接口的时候就需要涉及到结构体和Json之间的相互转化，Go Json序列化是指把结构体数据转化为Json格式的字符串，Go json反序列化是指把json数据转化为Golang中的结构体对象
Go 中的序列化与反序列化主要通过"encoding/json"包中的json.Marshal()和json.Unmarshal()方法

#### 结构体标签
Tag是结构体的元信息，可以在运行时的时候通过反射机制读取出来，Tag在结构体字段的后方定义，由一对**反引号**包裹起来，具体的格式如下
`key1:"value1" key2:value2` 可以定义多个tag标签
结构体tag由一个或者多个键值对组成，键与值使用冒号分割，值使用**双引号**括起来，同一个结构体字段可以设置多个键值对tag，不同的键值对tag之间使用空格分隔。
> 为结构体添加Tag时，必须严格遵守键值对的规则，结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，通过反射也无法正确取值，*例如不要在key和value之间添加空格*

![CleanShot 2024-01-14 at 22.49.26@2x.png](https://sharkerhub.oss-cn-beijing.aliyuncs.com/Obsidian/CleanShot%202024-01-14%20at%2022.49.26@2x.png)

> 对于嵌套结构体序列化与反序列化与正常的非嵌套的结构体的处理是一样的按照正常的Marshal搞就可以了

## Go 接口
Go中的接口是一种抽象数据类型,Go中接口定义了对象的行为规范，只定义规范不进行实现，接口中定义的规范需要由具体的对象来实现。
可以通俗的理解接口就是一个标准，他是对一个对象的行为和规范进行约定，约定实现接口的对象必须得按照接口的规范。

### Go 接口定义
在go中定义接口(interface)是一种类型，一种抽象的类型，接口是一组函数method的集合，go中的接口不能包含**任何变量**。
在go中接口中的所有方法都没有方法体，接口定义了一个对象的行为规范，只定义规范不实现，接口体现了程序设计的多态和高内聚低耦合的思想。
Go中的接口也是一种数据类型，不需要显示实现，只需要一个变量含有接口类型中的所有方法，那么这个变量就实现了这个接口。

```go
type 接口名 interface {
	方法名1(参数列表) 返回值列表
	方法名2(参数列表) 返回值列表
}
```
- 接口名 使用type将接口定义为自定义的类型名，GO语言的接口在命名时，一般在单词名后面添加er，如有写操作的接口叫Writer，有字符串功能的接口叫Stringer等，接口名最好要能突出该接口的类型含义。
- 方法名 当方法名首字母是大写且这个接口名首字母也是大写时，这个方法可以被接口所在的包之外的代码访问。
- 参数列表、返回值列表 参数列表和返回值列表中的参数变量名可以省略

> 接口定义的方法没有函数体，不需要给出具体的实现
> 如果接口里面有方法的话，必须要通过结构体或者自定义类型实现这个接口，要实现这个接口的话必须要实现接口中的所有方法(实现这 结构体或者自定义类型)


## Go 指针

## Go time包以及日期函数

## Go mod 与 Go包详解


## Go goroutine channel

## Go 反射

## Go 文件目录操作


